import Statement, StatementKind, ParsedType, ExpressionKind, TypeKind, Expression, DefnArgument from ./parser
import IdentifierOriginKind from ./infer

class generateTS(block:Statement[]^)
    public const result:string[]

    result.push(value: 'import { __index_get, __index_set, __slice, panic } from "./runtime"')
    result.push(value: 'import { generateTSImport, importScope } from "./tboot"')

    function dumpType(type: ParsedType^)
        result.push(value: " // " + formatParsedType(type))
    end

    function getInitValue(expr: Expression?, type: ParsedType?): string
        if expr <> nil
            return generateJSExpression(expr)
        elseif type?.kind = TypeKind.intType
            return "0"
        elseif type?.kind = TypeKind.arrayType
            return "[]"
        elseif type?.kind = TypeKind.boolType
            return "false"
        elseif type?.kind = TypeKind.mapType
            return "new " + generateTSType(type: type!) + "()"
        else
            return "null"
        end
    end

    function generateBlock(block: Statement[]^, forClass: bool, atRoot: bool)
        let exportClassifier := ""

        if atRoot
            exportClassifier := "export "
        end
       
        for stmt of block
            if stmt.kind = StatementKind.ConstStatement or stmt.kind = StatementKind.LetStatement
                const initValue := getInitValue(expr: stmt.value, type: stmt.type)
                let declaration := "let"

                if stmt.kind = StatementKind.ConstStatement
                    declaration := "const"
                end

                dumpType(type: stmt.type)
                if forClass and stmt.isPublic
                    result.push(value: "_o." + stmt.identifier + " = " + initValue + ";")
                elseif stmt.type <> nil
                    result.push(value: declaration + " " + stmt.identifier + ": " + generateTSType(type: stmt.type) + " = " + initValue + ";")
                else
                    result.push(value: declaration + " " + stmt.identifier + " = " + initValue + ";")
                end
            elseif stmt.kind = StatementKind.IfStatement
                result.push(value: "if (" + generateJSExpression(expr: stmt.value!) + ") {")
                generateBlock(block: stmt.block, forClass: false, atRoot: false)

                for ei of stmt.elseIf
                    result.push(value: "} else if (" + generateJSExpression(expr: ei.value) + ") {")
                    generateBlock(block: ei.block, forClass: false, atRoot: false)
                end
                if stmt.elseBlock.length > 0
                    result.push(value: "} else {")
                    generateBlock(block: stmt.elseBlock, forClass: false, atRoot: false)
                end
                result.push(value: "}")
            elseif stmt.kind = StatementKind.WhileStatement
                result.push(value: "while (" + generateJSExpression(expr: stmt.value!) + ") {")
                generateBlock(block: stmt.block, forClass: false, atRoot: false)
                result.push(value: "}")
            elseif stmt.kind = StatementKind.RepeatStatement
                result.push(value: "do {")
                generateBlock(block: stmt.block, forClass: false, atRoot: false)
                result.push(value: "} while (!(" + generateJSExpression(expr: stmt.value!) + "))")
            elseif stmt.kind = StatementKind.ForStatement
                result.push(value: "for (const " + stmt.identifier + " of " + generateJSExpression(expr: stmt.value!) + ") {")
                generateBlock(block: stmt.block, forClass: false, atRoot: false)
                result.push(value: "}")
            elseif stmt.kind = StatementKind.ForRangeStatement
                result.push(value: "for (let " + stmt.identifier + " = " + generateJSExpression(expr: stmt.lhs!) + "; " + stmt.identifier + " <= " + generateJSExpression(expr: stmt.value!) + "; " + stmt.identifier + "++) {")
                generateBlock(block: stmt.block, forClass: false, atRoot: false)
                result.push(value: "}")
            elseif stmt.kind = StatementKind.ForRangeExclusiveStatement
                result.push(value: "for (let " + stmt.identifier + " = " + generateJSExpression(expr: stmt.lhs!) + "; " + stmt.identifier + " <= " + generateJSExpression(expr: stmt.value!) + "; " + stmt.identifier + "++) {")
                generateBlock(block: stmt.block, forClass: false, atRoot: false)
                result.push(value: "}")
            elseif stmt.kind = StatementKind.AssignStatement
                if stmt.lhs!.kind = ExpressionKind.Index
                    if effectiveType(type: stmt.lhs!.left!.type).kind = TypeKind.mapType
                        result.push(value: generateJSExpression(expr: stmt.lhs!.left!) + ".set(" + generateJSExpression(expr: stmt.lhs!.indexes[0]) + ", " + generateJSExpression(expr: stmt.value!) + ");")
                    else
                        result.push(value: generateJSExpression(expr: stmt.lhs!.left!) + "[" + generateJSExpression(expr: stmt.lhs!.indexes[0]) + "] = " + generateJSExpression(expr: stmt.value!) + ";")
                    end
                else
                    result.push(value: generateJSExpression(expr: stmt.lhs!) + " = " + generateJSExpression(expr: stmt.value!) + ";")
                end
            elseif stmt.kind = StatementKind.ClassStatement
                result.push(value: exportClassifier + "function " + stmt.identifier + "(" + generateDefnArguments(args: stmt.defnArguments) + ") {")
                result.push(value: "const _o = {} as class_" + stmt.identifier + ";")

                for arg of stmt.defnArguments
                    if arg.isPublic
                        result.push(value: "_o." + arg.identifier + " = " + arg.identifier + ";")
                    end
                end

                generateBlock(block: stmt.block, forClass: true, atRoot: false)

                result.push(value: "return _o;")
                result.push(value: "}")
                generateTSInterface(definition: stmt)
            elseif stmt.kind = StatementKind.FunctionStatement
                result.push(value: exportClassifier + "function " + stmt.identifier + "(" + generateDefnArguments(args: stmt.defnArguments) + "):" + generateTSType(type: stmt.type) + " {")
    
                generateBlock(block: stmt.block, forClass: false, atRoot: false)
    
                result.push(value: "}")

                if forClass and stmt.isPublic
                    result.push(value: "_o." + stmt.identifier + " = " + stmt.identifier + ";")
                end
            elseif stmt.kind = StatementKind.EnumStatement
                result.push(value: "export enum " + stmt.identifier + " {")

                result.push(value: generateJSEnumValues(stmt))

                result.push(value: "};")
            elseif stmt.kind = StatementKind.ReturnStatement
                result.push(value: "return " + generateJSExpression(expr: stmt.value!) + ";")
            elseif stmt.kind = StatementKind.ImportStatement
                result.push(value: "// import goes here")
                result.push(value: generateTSImport(stmt))
            elseif stmt.kind = StatementKind.ExpressionStatement
                result.push(value: generateJSExpression(expr: stmt.value!) + ";")
            else
                result.push(value: "unknown")
            end
        end
    end

    function generateTSInterface(definition: Statement)
        if definition.kind = StatementKind.ClassStatement
            result.push(value: "export interface class_" + definition.identifier + " {")
    
            for arg of definition.defnArguments
                if arg.isPublic
                    result.push(value: arg.identifier + ":" + generateTSType(type: arg.type) + ";")
                end
            end
    
            for stmt of definition.block
                if stmt.kind = StatementKind.FunctionStatement
                    if stmt.isPublic
                        result.push(value: stmt.identifier + "(" + generateDefnArguments(args: stmt.defnArguments) + "):" + generateTSType(type: stmt.type) + ";")
                    end
                elseif stmt.kind = StatementKind.LetStatement or stmt.kind = StatementKind.ConstStatement
                    if stmt.isPublic
                        result.push(value: stmt.identifier + ":" + generateTSType(type: stmt.type) + ";")
                    end
                end
            end
    
            result.push(value: "}")
        end
    end
    
    generateBlock(block, forClass: false, atRoot: true)
end

function generateJSExpression(expr: Expression^):string
    if expr = nil
        return "*nil"
    end

    if expr.type.kind = TypeKind.unknownType and expr.kind <> ExpressionKind.NilConstant
        panic(message: "expression not inferred")
    end

    if expr.kind = ExpressionKind.LessThan
        return generateJSExpression(expr: expr.left!) + " < " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.GreaterThan
        return generateJSExpression(expr: expr.left!) + " > " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.Equals
        return generateJSExpression(expr: expr.left!) + " == " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.NotEquals
        return generateJSExpression(expr: expr.left!) + " != " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.GreaterThanEquals
        return generateJSExpression(expr: expr.left!) + " >= " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.LessThanEquals
        return generateJSExpression(expr: expr.left!) + " <= " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.Add
        return generateJSExpression(expr: expr.left!) + " + " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.Subtract
        return generateJSExpression(expr: expr.left!) + " - " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.Multiply
        return generateJSExpression(expr: expr.left!) + " * " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.Divide
        return generateJSExpression(expr: expr.left!) + " / " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.Or
        return generateJSExpression(expr: expr.left!) + " || " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.And
        return generateJSExpression(expr: expr.left!) + " && " + generateJSExpression(expr: expr.right!)
    elseif expr.kind = ExpressionKind.Dot
        return generateJSExpression(expr: expr.left!) + "." + expr.value
    elseif expr.kind = ExpressionKind.OptDot
        return generateJSExpression(expr: expr.left!) + "?." + expr.value
    elseif expr.kind = ExpressionKind.Not
        return "!" + generateJSExpression(expr: expr.left!)
    elseif expr.kind = ExpressionKind.Bang
        return generateJSExpression(expr: expr.left!) + "!"
    elseif expr.kind = ExpressionKind.IntConstant
        return expr.value!
    elseif expr.kind = ExpressionKind.NilConstant
        return "null"
    elseif expr.kind = ExpressionKind.BoolConstant
        return expr.value!
    elseif expr.kind = ExpressionKind.StringConstant
        return expr.value!
    elseif expr.kind = ExpressionKind.Identifier
        if expr.origin!.kind = IdentifierOriginKind.Field
            return "_o." +  expr.value!
        else
            return expr.value!
        end
    elseif expr.kind = ExpressionKind.Invoke
        return generateJSExpression(expr: expr.left!) + "(" + generateNamedArguments(type: expr.left!.type, args: expr.indexes, argNames: expr.identifiers) + ")"
    elseif expr.kind = ExpressionKind.Slice
        return "__slice(" + generateJSExpression(expr: expr.left!) + ", " + generateArguments(args: expr.indexes) + ")"
    elseif expr.kind = ExpressionKind.Index
        if expr.indexes.length = 0
            return "[]"
        end
        if effectiveType(type: expr.left!.type).kind = TypeKind.stringType
            return generateJSExpression(expr: expr.left!) + ".charCodeAt(" + generateArguments(args: expr.indexes) + ")"
        elseif effectiveType(type: expr.left!.type).kind = TypeKind.mapType
            return generateJSExpression(expr: expr.left!) + ".get(" + generateArguments(args: expr.indexes) + ")"
        elseif effectiveType(type: expr.left!.type).kind = TypeKind.arrayType
            return generateJSExpression(expr: expr.left!) + "[" + generateArguments(args: expr.indexes) + "]"
        else
            return "__index_get(" + generateJSExpression(expr: expr.left!) + ", " + generateArguments(args: expr.indexes) + ")"
        end
    else
        return "*expression*"
    end
end

function effectiveType(type: ParsedType) : ParsedType
    if type.kind = TypeKind.pointerType or type.kind = TypeKind.nullableType
        return effectiveType(type: type.ref!)
    end
    return type
end

function generateTSType(type: ParsedType?): string
    if type = nil
        return "any"
    end

    if type.kind = TypeKind.intType
        return "number"
    elseif type.kind = TypeKind.boolType
        return "boolean"
    elseif type.kind = TypeKind.stringType
        return "string"
    elseif type.kind = TypeKind.arrayType
        return generateTSType(type: type.ref) + "[]"
    elseif type.kind = TypeKind.pointerType
        return generateTSType(type: type.ref)
    elseif type.kind = TypeKind.nullableType
        return generateTSType(type: type.ref) + " | null"
    elseif type.kind = TypeKind.objectType
        if type.stmt?.kind = StatementKind.ClassStatement
            return "class_" + type.identifier!
        elseif type.stmt?.kind = StatementKind.EnumStatement
            return type.identifier!
        end
        return "any"
    elseif type.kind = TypeKind.mapType
        return "Map<" + generateTSType(type: type.mapKeyRef) + "," + generateTSType(type: type.ref) + ">"
    elseif type.kind = TypeKind.functionType
        return "Function"
    elseif type.kind = TypeKind.voidType
        return "void"
    elseif type.kind = TypeKind.enumType
        return type.identifier!
    else
        return "any"
    end
end

function generateDefnArgument(arg: DefnArgument): string
    return arg.identifier + ":" + generateTSType(type: arg.type)
end

function generateDefnArguments(args: DefnArgument[]^): string
    if args.length = 0
        return ""
    end

    let result := generateDefnArgument(arg: args[0])
    let idx := 1
    while idx < args.length
        result := result + "," + generateDefnArgument(arg: args[idx])
        idx := idx + 1
    end
    return result
end

function generateNamedArguments(type: ParsedType, args: Expression[], argNames: string[]): string
    if type.kind <> TypeKind.functionType and type.kind <> TypeKind.classType 
        panic(message: "not a function type")
    end
    const defnArguments := type.stmt!.defnArguments

    if defnArguments.length = 0
        return ""
    end

    function generateClosureParams(args: DefnArgument[]^): string
        if args.length = 0
            return ""
        end

        let result := args[0].identifier
        let idx := 1
        while idx < args.length
            result := result + "," + args[idx].identifier
            idx := idx + 1
        end
        return result
    end

    function generateArg(idx: int): string
        const argType := defnArguments[idx].type
        let aidx := 0
        while aidx < argNames.length
            if argNames[aidx] = defnArguments[idx].identifier
                if argType.kind = TypeKind.functionType
                    return "(" + generateClosureParams(args: argType.stmt!.defnArguments) + ")=>" + generateJSExpression(expr: args[aidx])
                end

                return generateJSExpression(expr: args[aidx])
            end
            aidx := aidx + 1
        end

        if defnArguments[idx].value <> nil
            return generateJSExpression(expr: defnArguments[idx].value!)
        end

        panic(message: "missing argument " + defnArguments[idx].identifier + " in call to " + type.stmt!.identifier!)
        return ""
    end

    let result := generateArg(idx: 0)

    let idx := 1
    while idx < defnArguments.length
        result := result + ", " + generateArg(idx: idx)
        idx := idx + 1
    end

    let aidx := 0
    while aidx < argNames.length
        let found := false
        let didx := 0
        while didx < defnArguments.length
            if argNames[aidx] = defnArguments[didx].identifier
                found := true
            end
            didx := didx + 1
        end
        if not found
            panic(message: "unknown argument " + argNames[aidx] + " in call to " + type.stmt!.identifier!)
        end
        aidx := aidx + 1
    end

    return result
end

function generateArguments(args: Expression[]^): string
    if args.length = 0
        return ""
    end
    let result := generateJSExpression(expr: args[0])
    let idx := 1
    while idx < args.length
        result := result + ", " + generateJSExpression(expr: args[idx])
        idx := idx + 1
    end
    return result
end

function generateJSEnumValues(stmt: Statement^): string
    let result := stmt.identifierList[0]

    let idx := 1
    while idx < stmt.identifierList.length
        result := result + ", " + stmt.identifierList[idx]
        idx := idx + 1
    end

    return result
end

function formatParsedType(type: ParsedType?): string
    if type = nil
        return "no type"
    elseif type.kind = TypeKind.objectType
        if type.stmt = nil
            return "object"
        else
            return "object<" + type.stmt.identifier + ">"
        end
    elseif type.kind = TypeKind.arrayType
        return "array<" + formatParsedType(type: type.ref) + ">"
    elseif type.kind = TypeKind.stringType
        return "string"
    elseif type.kind = TypeKind.intType
        return "int"
    elseif type.kind = TypeKind.boolType
        return "bool"
    elseif type.kind = TypeKind.nullableType
        return "nullable<" + formatParsedType(type: type.ref) + ">"
    else
        return "unknown"
    end
end

