import Token, Tokeniser from ./tokeniser
import Statement, StatementKind, ParsedType, ExpressionKind, TypeKind, Expression, DefnArgument from ./parser

function descopeCode(args: DefnArgument[]^, block: Statement[]^, outerScope: string[string]?, forClass: bool)
    const scopeSet:string[string]

    if outerScope <> nil
        for key of outerScope.keys()
            scopeSet.set(key: key, value: outerScope.get(key: key)!)
        end
    end

    for arg of args
        if arg.isPublic and forClass
            scopeSet.set(key: arg.identifier, value: "_o." + arg.identifier)
        else
            scopeSet.delete(key: arg.identifier)
        end
    end
    for stmt of block
        if stmt.kind = StatementKind.ConstStatement or stmt.kind = StatementKind.LetStatement
            if stmt.isPublic and forClass
                scopeSet.set(key: stmt.identifier!, value: "_o." + stmt.identifier)
            else
                scopeSet.delete(key: stmt.identifier!)
            end
        end
    end    

    descopeBlock(block)

    function descopeBlock(block: Statement[]^)
        let idx := 0
        while idx < block.length
            const stmt := block[idx]
            idx := idx + 1
            if stmt.kind = StatementKind.FunctionStatement or stmt.kind = StatementKind.ClassStatement
                descopeCode(args: stmt.defnArguments, block: stmt.block, outerScope: scopeSet,  forClass: stmt.kind = StatementKind.ClassStatement)
            elseif stmt.kind = StatementKind.IfStatement
                stmt.value := descopeExpression(expr: stmt.value!)
                for ei of stmt.elseIf
                    ei.value := descopeExpression(expr: ei.value!)
                    descopeBlock(block: ei.block)
                end
                descopeBlock(block: stmt.block)
                descopeBlock(block: stmt.elseBlock)
            elseif stmt.kind = StatementKind.ForStatement or stmt.kind = StatementKind.WhileStatement
                stmt.value := descopeExpression(expr: stmt.value!)
                descopeBlock(block: stmt.block)
            elseif stmt.kind = StatementKind.ExpressionStatement
                stmt.value := descopeExpression(expr: stmt.value!)
            elseif stmt.kind = StatementKind.ReturnStatement
                stmt.value := descopeExpression(expr: stmt.value!)
            elseif stmt.kind = StatementKind.LetStatement or stmt.kind = StatementKind.ConstStatement
                if stmt.value <> nil
                    stmt.value := descopeExpression(expr: stmt.value!)
                end
            elseif stmt.kind = StatementKind.AssignStatement
                stmt.value := descopeExpression(expr: stmt.value!)
                stmt.lhs := descopeExpression(expr: stmt.lhs!)
            end
        end
    end

    function descopeExpression(expr: Expression):Expression
        if expr.kind = ExpressionKind.Identifier
            if scopeSet.has(key: expr.value!)
                expr.value := scopeSet.get(key: expr.value!)!
            end
        elseif expr.kind = ExpressionKind.Equals or expr.kind = ExpressionKind.NotEquals or expr.kind = ExpressionKind.LessThan or expr.kind = ExpressionKind.LessThanEquals
                or expr.kind = ExpressionKind.GreaterThan or expr.kind = ExpressionKind.GreaterThanEquals
                or expr.kind = ExpressionKind.And or expr.kind = ExpressionKind.Or
                or expr.kind = ExpressionKind.Add or expr.kind = ExpressionKind.Subtract or expr.kind = ExpressionKind.Multiply or expr.kind = ExpressionKind.Divide
            expr.left := descopeExpression(expr: expr.left!)
            expr.right := descopeExpression(expr: expr.right!)
        elseif expr.kind = ExpressionKind.Dot
            expr.left := descopeExpression(expr: expr.left!)
        elseif expr.kind = ExpressionKind.OptDot
            expr.left := descopeExpression(expr: expr.left!)
        elseif expr.kind = ExpressionKind.Index or expr.kind = ExpressionKind.Slice
            expr.left := descopeExpression(expr: expr.left!)
            let idx := 0
            while idx < expr.indexes.length
                expr.indexes[idx] := descopeExpression(expr: expr.indexes[idx])
                idx := idx + 1
            end
        elseif expr.kind = ExpressionKind.Invoke
            expr.left := descopeExpression(expr: expr.left!)
            let idx := 0
            while idx < expr.indexes.length
                expr.indexes[idx] := descopeExpression(expr: expr.indexes[idx])
                idx := idx + 1
            end
        end
        return expr
    end
end
